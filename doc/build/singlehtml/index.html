
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FELLOW_project 0.0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-fellow-project-s-documentation">
<h1>Welcome to FELLOW_project’s documentation!<a class="headerlink" href="#welcome-to-fellow-project-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-intro"></span><div class="section" id="this-is-an-introduction-to-my-documentation">
<h2>This is an introduction to my documentation!<a class="headerlink" href="#this-is-an-introduction-to-my-documentation" title="Permalink to this headline">¶</a></h2>
<p>Here you can find a list of the current packages I have written for
this project. They all include numpy docstrings!</p>
<p>Here are some helpful pointers regarding the creation of the autodocs:</p>
<ul class="simple">
<li><p>You need to have the extension <cite>sphinx.ext.autodocs</cite> added to the conf.py</p></li>
<li><p>You also need to add  <cite>.. automodule:: [module_name]</cite></p></li>
</ul>
<blockquote>
<div><p>to the rst file you wantto add the script’s documentation to.</p>
</div></blockquote>
<ul class="simple">
<li><p>Important note: the autodocs automatically goes loads any string comment</p></li>
</ul>
<p>(<cite>“””[comment]”””</cite>) with restructured text when writing the documentation.</p>
<ul class="simple">
<li><p>Also, any script being documented need to include a <cite>if __name__ == ‘__main__’</cite></p></li>
</ul>
<div class="section" id="module-basic_code">
<span id="current-modules"></span><h3>Current modules<a class="headerlink" href="#module-basic_code" title="Permalink to this headline">¶</a></h3>
<p>This first one is a basic function that includes the code you would need to
add two numbers together!</p>
<div class="section" id="why-is-this-function-useful">
<h4>Why is this function useful?<a class="headerlink" href="#why-is-this-function-useful" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>It can replace the ‘+’ key!</p></li>
<li><p>It can cause you to bill more hours for less work since the import takes
extra time to type!</p></li>
<li><p>It can serve as a helpful demo.</p></li>
</ul>
<p>Written by John Lewis Corker</p>
<dl class="py function">
<dt id="basic_code.basic_google">
<code class="sig-prename descclassname">basic_code.</code><code class="sig-name descname">basic_google</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basic_code.basic_google" title="Permalink to this definition">¶</a></dt>
<dd><p>A basic addition google function.</p>
<p>This function contains a basic google docstring that we should be able to
look at and compare.</p>
<dl>
<dt>Usage below:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basic</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">13</span>
</pre></div>
</div>
</dd>
<dt>Args:</dt><dd><p>x (int): a basic variable that will be added to the y value</p>
<p>y (int): a basic variable that will be added to the x value</p>
</dd>
<dt>Returns:</dt><dd><p>int: The value of x and y added together</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="basic_code.basic_numpy">
<code class="sig-prename descclassname">basic_code.</code><code class="sig-name descname">basic_numpy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basic_code.basic_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>A very basic addition numpy function.</p>
<p>This function contains a basic numpy docstring that we should be able to
look at and compare.</p>
<dl>
<dt>Usage below:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basic</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">13</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="simple">
<dt>x<span class="classifier">int</span></dt><dd><p>This is a basic variable that will be added to the y value.</p>
</dd>
<dt>y<span class="classifier">int</span></dt><dd><p>This is a basic variable that will be added to the x value.</p>
</dd>
</dl>
<dl class="simple">
<dt>int</dt><dd><p>The value of x and y added together</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>
<span id="document-ODESSA_docs/ODESSA"></span><div class="section" id="this-shows-the-documentation-of-my-odessa-scripts">
<h2>This shows the documentation of my ODESSA scripts!<a class="headerlink" href="#this-shows-the-documentation-of-my-odessa-scripts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-MCMC">
<span id="scripts"></span><h3>Scripts<a class="headerlink" href="#module-MCMC" title="Permalink to this headline">¶</a></h3>
<p>A function to perform Markov Chain Monte Carlo on the sample distributions
generated in stat_dists.py</p>
<p>Of note is that technically the sample distributions are Markov Chains sampled
from the base distribution</p>
<p>&#64;author John Lewis Corker</p>
<dl class="py function">
<dt id="MCMC.AHMC">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">AHMC</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.AHMC" title="Permalink to this definition">¶</a></dt>
<dd><p>This function initializes a Theta value and then advances the hamiltonian
for a certain amount of values.
&#64;profiler</p>
</dd></dl>

<dl class="py function">
<dt id="MCMC.adapt_ADHMC">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">adapt_ADHMC</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">e</span></em>, <em class="sig-param"><span class="n">diff</span></em>, <em class="sig-param"><span class="n">err</span></em>, <em class="sig-param"><span class="n">count</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.adapt_ADHMC" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should attempt to optimize the value of e picked for the
adaptive Hamiltonian MCMC runs. We know that there are areas of the
parameter space which are prone to large errors and some areas prone to
small areas. This seeks to take in the previous time step and the amount of
error that occured in the Hamiltonian and then adapt it to better suit the
range we are in.</p>
</dd></dl>

<dl class="py function">
<dt id="MCMC.check_theta">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">check_theta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">N</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.check_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>This ensures that the new theta value is comprised of valid inputs in our
parameter space. We perform a reflection in order to preserve the
Hamiltonian’s phase space volume. (Liouville’s Theorem)</p>
<p>Implementation based on the implementation for a bounded HMC from
Dr. Radford M. Neal’s GRIMS: <a class="reference external" href="http://www.cs.utoronto.ca/~radford/GRIMS.html">http://www.cs.utoronto.ca/~radford/GRIMS.html</a></p>
</dd></dl>

<dl class="py function">
<dt id="MCMC.fix_illcondition">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">fix_illcondition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.fix_illcondition" title="Permalink to this definition">¶</a></dt>
<dd><p>As the FIM becomes ill-defined when two of the parameters converge to their
truth values, causing the final parameter to greatly increase and thereby
throw the parameters off, we must check the FIM to ensure it is well
behaved, else we approximate it’s inverse with a new method proposed in the
paper:</p>
<blockquote>
<div><p><a class="reference external" href="https://core.ac.uk/download/pdf/26121748.pdf">https://core.ac.uk/download/pdf/26121748.pdf</a></p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="MCMC.get_FIM">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">get_FIM</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.get_FIM" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Fisher information Matrix which becomes our mass matrix in
the RMHC</p>
<p>From equation 25/28</p>
</dd></dl>

<dl class="py function">
<dt id="MCMC.get_derivates_flux">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">get_derivates_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.get_derivates_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the derivate of the flux</p>
<p>From appendix A</p>
</dd></dl>

<dl class="py function">
<dt id="MCMC.get_potential">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">get_potential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">N</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.get_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should generate the sampling from the new theta
distribution that has been passed in.</p>
</dd></dl>

<dl class="py function">
<dt id="MCMC.grad_potential">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">grad_potential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">N</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.grad_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates the gradient vector for the likelihood function
based on the derivative I calculated. It takes the lightcurve and gets the
difference between the flux and expected flux to find out differences.</p>
<p>For use in equation 24/function hamiltonian</p>
</dd></dl>

<dl class="py function">
<dt id="MCMC.hamiltonian">
<code class="sig-prename descclassname">MCMC.</code><code class="sig-name descname">hamiltonian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curr_theta</span></em>, <em class="sig-param"><span class="n">L</span></em>, <em class="sig-param"><span class="n">e</span></em><span class="sig-paren">)</span><a class="headerlink" href="#MCMC.hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>This function seeks to define and return the structure of the Hamiltonian
for use in the acception/rejection process</p>
<p>From Section 4</p>
</dd></dl>

<span class="target" id="module-stat_dists"></span><p>Implementing the different statistical distributions that are listed in the
paper.</p>
<p>&#64;author John Lewis Corker</p>
<dl class="py function">
<dt id="stat_dists.get_flux_measurement">
<code class="sig-prename descclassname">stat_dists.</code><code class="sig-name descname">get_flux_measurement</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">num_facets</span></em><span class="sig-paren">)</span><a class="headerlink" href="#stat_dists.get_flux_measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the hypothetical measured flux of a non-Lambertian
BDRF light curve</p>
<p>From equation 4</p>
</dd></dl>

<dl class="py function">
<dt id="stat_dists.likelihood_dist">
<code class="sig-prename descclassname">stat_dists.</code><code class="sig-name descname">likelihood_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">lightcurve</span></em>, <em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">facets</span></em>, <em class="sig-param"><span class="n">obs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#stat_dists.likelihood_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine a representative sample of the likihood function</p>
<p>This uses the distribution from the scipy_dist class.</p>
<p>From equation 10</p>
</dd></dl>

<dl class="py function">
<dt id="stat_dists.theta_prior">
<code class="sig-prename descclassname">stat_dists.</code><code class="sig-name descname">theta_prior</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta_obj</span></em>, <em class="sig-param"><span class="n">lightcurve</span></em><span class="sig-paren">)</span><a class="headerlink" href="#stat_dists.theta_prior" title="Permalink to this definition">¶</a></dt>
<dd><p>The prior distribution for the input parameters in the start of the run.</p>
<p>From equation 9</p>
</dd></dl>

<dl class="py function">
<dt id="stat_dists.visibility_prior">
<code class="sig-prename descclassname">stat_dists.</code><code class="sig-name descname">visibility_prior</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_obs</span></em>, <em class="sig-param"><span class="n">vector</span></em>, <em class="sig-param"><span class="n">lightcurve</span></em><span class="sig-paren">)</span><a class="headerlink" href="#stat_dists.visibility_prior" title="Permalink to this definition">¶</a></dt>
<dd><p>A distribution which 0 if the facet is not reflextive and 1 if it is curr.
reflecting light towards the observer. m is the maximum time of
measurements</p>
<p>From eauation 8</p>
</dd></dl>

</div>
</div>
<span id="document-EMADE"></span><div class="section" id="emade-documentation">
<h2>EMADE Documentation<a class="headerlink" href="#emade-documentation" title="Permalink to this headline">¶</a></h2>
<p>This is an autogenerated script that pulls out the current
state of EMADE’s documentation.</p>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">FELLOW_project</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-intro">This is an introduction to my documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-ODESSA_docs/ODESSA">This shows the documentation of my ODESSA scripts!</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-EMADE">EMADE Documentation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, John Lewis Corker.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>